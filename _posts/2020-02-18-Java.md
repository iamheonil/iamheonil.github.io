---
layout: post
comments : true
title: 'Start Java'
date: 2020-02-18
author: Kim Heonil
tags: Java
---

> 깜빡할 때마다 읽어보려고 만들었습니다. <br>

<p></p><br>

### 지켜야 할 약속, 꼭 알고 있어야 하는 부분

변수명, 패키지명, 메소드명은 소문자로 시작한다.<br>
클래스명, 프로젝트명은 대문자로 시작한다.<br>

인스턴스 변수 - 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 생성해야한다. <br>
클래스 변수 - 인스턴스 변수에 static만 붙여주면 된다.

스태틱은 정적으로 값이 변하지 않는다. 선언하면 프로그램이 종료될 때 까지 값이 고정이다. <br>
그러나 선언된 함수나 공간에서만 사용이 된다. <br>
스태틱을 선언하면 프로그램이 종료될 때 까지 값을 가지고 있고 종료되면 사라진다. <br>

지역 변수 - 메서드 내에서 선언하며 선언된 메서드 내에서만 사용할 수 있는 변수이다.<br>
메서드가 실행될 때 메모리를 할당 받으며 메서드가 끝나면 소멸된다.<br>

<br><br>

### 기초

변수 - 데이터를 저장하는 메모리의 공간, 저장할 수 있는 데이터의 형식을 대입하여 사용한다. <br>
메소드 - 기능을 뜻한다. <br>
형변환 - 연산은 반드시 피연산자들이 같은 데이터타입일 때 가능하여, 서로 다른 연산자라면 형변환을 하고 연산을 해줘야한다. <br>
<br>
연산자의 종류 <br>
 + 기본연산자 : +, -, *, / <br>
 + 단항연산자 : +, -, ++, --, <br>
 + 이항연산자 : 비교 연산자라고도 한다. (<, >, <=, >=, ==, !=) <br>
 + 단항연산자 : (&&, ||, !) <br>
 + 삼항연산자 : ?: <br>
 + 복합대입연산자 산술대입 : +=, -=, *=, /=, %= <br>
 + 추가로 (https://t1.daumcdn.net/cfile/tistory/2219753856A8E8D92E) 참고. <br>

<br><br>

### 할당

정적 할당 : 프로그램 실행 전에 준비가 끝나는 할당, Compile-time <br>
동적 할당 : 프로그램 실행 도중에 준비, Run-time <br>
배열 변수를 선언해주는것은 정적 할당에 해당되고 변수가 사용할 공간을 생성해주는것은 동적할당에 해당된다. <br>

얕은 복사 : 참조 대상의 주소만 복사했을 때 발생한다. <br>
깊은 복사 : 참조 대상의 내용물을 새로운 공간에 복사한다. <br>

얕은 복사와 깊은 복사의 차이는 <br>
공간을 생성해주지 않고 단순 대입을 통한 복사인지 <br>
공간을 생성해준 상태에서 값을 그대로 복사하여 삽입하는것인가의 차이. <br>

<br><br>

### 객체지향

인스턴스(객체) : 클래스 정의 코드를 통해서 생성된 객체, 메모리에 생성 돼 있다. <br>
인스턴스화(실체화) : 메모리에 실체화 하는 작업 (new 연산자를 사용한다. 그러므로 동적 할당.) <br>
정적바인딩과 동적바인딩 : 컴파일 직후 바인딩 되는것은 정적 바인딩, 프로그램이 실행될 때 바인딩 되는것을 동적바인딩이라고 한다.<br>
쉽게 얘기하면 Ctrl + F11 을 눌러 컴파일을 하게 될 때 동작이 정해진 것이 정적바인딩, <br>
(변수의 데이터 타입을 지정해주는것을 생각하면 이해가 쉽다.)<br>
프로그램이 실행되면서 객체의 동작이 정해지는것이 동적 바인딩이다.<br>

<br><br>

### 클래스

기능 클래스 - 메인메소드 없이 기능만 가지고 있는 클래스 <br>
멤버 필드 - 데이터의 정보, 속성만 가지고 있다. <br>
멤버 메소드 - 기능, 행위, 동작을 한다. <br>
<br>
추상 클래스 - 일반 클래스가 완성된 설계도라면 추상 클래스는 미완성 설계도와 같다.<br>
흐름상 서브클래스에서 값을 바꿔야 하는 상황이 발생한다면 추상 클래스, 메소드를 만든다.<br>
변할 가능성이 있는 기능들은 추상클래스와 메소드로 구현하고 변할 가능성이 없는 기능들은 일반 클래스로 만든다.<br>
<br>
추상 메소드 - 미완성 되어 있는 메소드를 서브클래스(자식클래스)에서 구현한다. <br>
추상 클래스에서 미구현한 '접근제한자 abstract void 메소드명();' 을 상속받아 오버라이딩하고<br>
알맞은 기능을 구현하여 사용할 수 있도록 한다!<br>

<br><br>

### 메소드와 함수

메소드(Method), 함수 (Function) <br>
클래스이 기능 또는 동작 또는 행위 등을 정의하는 코드 <br>
객체 변수를 통해 호출하여 사용한다. <br>
객체들 간의 데이터 전달(주고 받는) 수단으로 사용한다. <br>
<br>

메소드의 기본형태 작성

  1. 메소드 이름 작명, 만들고자 하는 기능을 대표하는 이름으로 적절히 작명한다.
  2. 매개변수를 작성한다. ( )의 안을 채우는 작업 -> 기능을 수행하는데 필요한 입력 값을 저장하는 변수.
  3. 실행코드를 작성한다. { }의 안을 채우는 작업 -> 메소드가 수행할 기능을 작성, 구현한다.
  4. 리턴코드를 작성한다. 실행코드 작성 후 실행코드의 처리를 어떻게 할 것인지 정한다.
  5. 리턴코드의 데이터타입을 작성한다. return 코드 값의 데이터 타입을 명시한다.

메소드 정의 방법 <br>

접근제한자 리턴타입 메소드의 이름 (매개변수) { <br>
 			실행코드 <br>
 } <br>
<br>

ex)

```java
public int add (int num1, int num2) {
 		// 실행코드
        int result = num1 + num2;
                                     
        return result;
        // 실행결과 num1 + num2 가 리턴.
 }
```

<br>

return 데이터가 없으면 return 타입은 void로 작성한다. <br>
void - 텅 빈, 공허한 <br>

매개변수가 없다면 괄호 ( ) 안을 비어둔다. <br>

<br><br>

### 클래스 선언

클래스의 정의 <br>

접근제한자 클래스식별자 'class' 클래스명 {  
	// 멤버필드  
	// 멤버메소드<br>

}<br>

ex)

```java
public class MemberField_01 {
	// 변수선언으로 만드는 곳 스택 메모리
	// 멤버 필드
	
	private int num = 1995;
	private String name = "Heonil";
	
	public int getNum() {
		return num;
	}
	public void setNum(int num) {
		this.num = num;
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

}
```

접근제한자 : public, 붙이지 않음(default) <br>
public - .java 파일의 이름과 같은 클래스명일 경우 붙일 수 있다. <br>
			하나의 java 파일 안에서는 하나의 public 클래스만 정의할 수 있다. <br>
Test.java 라는 파일이면 public class Test { 만 정의할 수 있다는 말. <br>
class A, B를 만들고 앞에 public class A, B를 붙이면 에러가 표시된다. <br>
default - public 클래스 이외의 클래스에게 사용, 위의 예시라면 A, B 에 default를 붙이는게 맞다. <br>
<br>
클래스 식별자 : 클래스의 용도에 따라서 식별할 수 있도록 사용하는 키워드 <br>
abstract, final, static <br>
추상,	파이널,	정적 <br>
<br>

선언방법과 주의사항

1. 클래스명 : 첫글자를 식별자라고 하며 영어 대문자로 사용해야한다.
2. 멤버 필드 : 클래스를 구성하는 변수와 상수를 포함한다. 주로 변수로 구성된다.
3. 객체가 생성될 때마다 각각의 객체마다 변수공간을 따로 가지게 된다.
4. 멤버 메소드 : 객체의 기능이나 행위를 정의하는 코드 

<br><br>
객체 변수 선언하기 <br>
클래스명 객체변수명; <br>
		
객체 생성하기(인스턴스화) <br>
객체변수명 = new 클래스명(); <br>
		
객체의 멤버에 접근하기(참조하기) <br>
객체변수명.멤버필드명 <br>
객체변수명.멤버메소드이름(); <br>
** 참조연산자 '.' 을 이용하여 객체변수를 통해 멤버에 접근할 수 있다. <br>
묶어 놓은것, 필드와 메소드를 관리하며 프로그램이 돌아가게끔 <br>
<br>
Getter Method  <br>
멤버필드의 값을 가져올 수 있도록 만든 메소드 <br>
가져온다(읽기) <br>
메소드명을 get 으로 시작하고 멤버필드의 첫 글자를 대문자로 작성한다. <br>

public 데이터타입 getXyz() { <br>
 return 필드의 변수명; <br>
} <br>
<br>
ex) Getter Method <br>
private int num;  멤버필드 num -> <br>
public int getNum() { <br>
		return num; <br>
} <br>
<br>
Setter Method <br>
멤버필드의 값을 설정할 수 있도록 만든 메소드 <br>
쓰기 <br>
메소드명을 set 으로 시작하고 멤버필드의 첫 글자를 대문자로 작성한다. <br>
public void setXyz(해당필드의 데이터타입 필드명) { <br>
		this.필드명 = 필드명; <br>
} <br>
<br>
ex) Setter Method <br>
private int num;  멤버필드 num -> <br>
public void setXyz(int num) { <br>
				this.num = num; <br>
}<br>
<br>
클래스 내부에서 사용되는 변수의 유형 <br>
인스턴스 변수, 클래스 변수, 지역 변수 <br>
Instance Variable, Class, 	Local <br>
<br>
인스턴스 변수 <br>
객체를 인스턴스화 했을 때 인스턴스 안에 만들어지는 변수마다 공간이 따로 배정된다. <br>
<br>
클래스 변수 <br>
정적 변수라고도 하며 Static 키워드가 적용된 멤버 필드를 뜻한다. <br>
클래스 당 하나의 공간을 관리하는 변수. <br>
프로그램이 실행되기 전(Ctrl + F11 를 누른 바로 직후 - 정적인 시점)에 미리 메모리의 클래스 영역에 생성한다. <br>
해당 클래스 타입으로 생성된 객체들이 하나의 공간을 공유한다. <br>
객체를 생성하지 않아도 클래스 멤버를 사용할 수 있다. <br>
<br>
지역 변수 <br>
메소드 내에서 선언된 변수 <br>
접근제한자 사용할 수 없다. <br>
매개변수도 지역변수로 취급됨. <br>
메소드마다 별도의 공간을 가지게 된다. (스택 메모리영역), 같은 이름의 변수가 다른 메소드에 존재 가능하다. <br>
초기화하지 않으면 쓰레기 값을 가지고 있게된다. <br>

<br><br>

### 메소드 오버로딩
메소드 오버로딩(Method Overloading), 정해져있는 한계량보다 더더더더더더더 <br>
같은 이름의 메소드를 여러 개 정의하는 것. <br>

비슷한 기능을 하는 추가 메소드를 개발하기 위해 별도의 이름을 사용하지않고 기존의 메소드 이름을 사용할 수 있게 해준다. <br>

메소드 오버로딩 성립 조건 <br>
1. 매개변수가 달라야한다. (정확히는 데이터 타입이 달라야 함)
2. 매개변수에 들어간 데이터타입의 갯수가 달라야한다.
3. 반환 데이터타입은 오버로딩과 상관 없다. 

ex)
```java
public class Overloading_01 {
	
	private int x;
	private int y;

	// 멤버필드 x, y 를 출력하는 메소드 구현
	public void display() { // 매개변수가 없는 Display
		System.out.println("( " + x + ", " + y + " )");
	}
	
	// 매개변수를 대입해 메소드 오버로딩 기능을 구현.
	// int 형 2개를 전달인자로 받아 멤버 x, y 를 초기화 및 출력
	public void display(int x, int y) { // 매개변수가 있는 Display
		this.x = x;		// 초기화
		this.y = y;		// 초기화
		
    // System.out.println("( " + x + ", " + y + " )");	// 출력
    // 위의 display 가 x, y 를 출력하기 때문에 sysout 을 쓰는게 아니라 display(); 를 불러와 사용해도 된다.
		
		display();
		// 코드의 재사용
	}
	
	public void display(double d) {				//	다른
	}

	public void display(String d) {				//	타입의
	}

	public void display(int d) {				//	데이터형
	}
	
	// 리턴타입이 void, int 등 상관없이 메소드 오버로딩과는 연관이 없다.
	// 무조건 데이터형의 갯수와 타입이 달라야한다.
}
```

<br><br>

### 클래스 다이어그램
프로그램 설계 시 클래스의 형태, 구조, 클래스간의 관계를 일정한 규칙과 기호등을 사용해 표현한 것. <br>
시스템의 논리적 구조를 표현한 다이어그램 <br>
** 논리적 구조 = 클래스의 구조 + 클래스들 간의 관계 <br>

```java
//======================================================================

// |===========================|	- 접근제한자 표현 기호
// |                           |	- + : public
// |         클래스 이름          |	  - # : protected
// |                           |	- ~ : default
// |===========================|	- - : private
// |                           |
// |                           |	멤버필드 표기 예시
// |                           |	private String name	=> - name : String
// |                           |	public int num;		=> + num : int
// |          멤버 필드          |	  double height		  => ~ height : double
// |                           |
// |                           |	멤버 메소드 표기 예시
// |                           | 	public String getName() { }     => + getName() : String	
// |                           |	private double out(int n1) { }	=> - display(int) : double
// |===========================|
// |                           |	- 스테레오 타입, Stereotype
// |         멤버 메소드          |	  - 특수한 기능을 수행함을 표현하는것.
// |                           |	- <<Override>> 처럼 <<기능>> 로 표현한다. 주석처럼 사용한다.
// |===========================|    
//      Class Diagram
```

<br><br>

### 생성자
new Overloading(); <br>
Scanner sc = new Scanner(System.in); <br>
       ↑↑↑ 생성자 ↑↑↑ <br>
객체가 생성될 때 반드시 호출되는 특수한 메소드 생성자는 객체를 초기화 한다. <br>
생성된 이후에 최초로 가져야 할 값을 지정(대입)한다.			   ] 같은 <br>
객체가 가지고 있는 멤버필드(인스턴스 변수)를 초기화 한다.	      ] 말이다. <br>
생성자를 정의하지 않는다면 디폴트 생성자를 컴파일러가 자동으로 추가한다. <br>
생성자가 하나라도 정의되어 있다면 디폴트 생성자는 당연히 없다. <br>
<br>
this 키워드
자기 참조 객체
클래스 코드에서(설계 클래스) 다른 멤버를 지칭할 때 사용한다.
주로 멤버필드와 매개변수가 같은 이름일 때 서로를 구분하기 위해 사용한다.
Setter를 사용해도 된다. 실제로 본인은 this 키워드보다 setter 키워드를 더 많이 사용한다. <br>
<br>
this() 생성자 <br>
생성자 코드에서 다른 생성자를 호출할 때 사용한다. <br>
다른 생성자에서 이미 정의 되어져있는 초기화 코드를 다시 작성하지 않고 재사용할 수 있게 된다. <br>

<br><br>

### UML
Unified Modeling Language <br>
통합 모델링 도구(언어) <br>
프로젝트 참가자들이 의사소통을 원활하게 하기 위해 작성하는 문서를 작성하는 도구. <br>
<br>
** 프로젝트 참가자 : 기획자, 개발자, 디자이너, 사장, 대표, 고객사, 의뢰인, 사용자 등등. <br>
기획, 설계, 구현으로 이루어진 프로그램 개발 절차에서 발생하는 중간 산출물을 표현하기 위해 표준화된 모델링 언어. <br>
기획 - 프로그램의 방향성 <br>
설계 - 프로그램 구현(개발)에 대한 방향 제시 <br>
구현 - 기획, 설계를 통하여 실체화 해내는 것. <br>
<br>
산출물의 종류 <br>
1. 화면정의서
    - 화면을 구현하기 위한 설계 문서
    - 요구사항 명세서, 정의서
		 - 프로그램의 요구사항을 정리한 문서
		 	- 명세서는 세세하게 정의서는 정의한것
			** 요구사항 : 프로그램에서 개발해야하는 것들, 주의해야하는 것들

2. 유스케이스 다이어그램
    - 요구사항에 있는 기능들을 표현한 그림,
        - 프로그램을 사용하는 행위자(Actor)를 중심으로 표현한다.

3. 클래스 다이어그램
    - 클래스들의 구조를 표현한 것(정적)

4. 시퀀스 다이어그램
    - 클래스의 동작을 표현한 것(동적)

5. 패키지 다이어그램
    - 프로그램의 패키지를 표현한 것.

<br><br>

### 큰 제목

<br><br>

### 큰 제목

<br><br>

### 큰 제목

<br><br>
kh20200213